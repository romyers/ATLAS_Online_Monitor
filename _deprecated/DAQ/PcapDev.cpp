#include <stdio.h>
#include <stdlib.h>
#include <pcap.h> 
#include <sys/socket.h>

#include "PcapDev.h"
#include "EthernetCap.h"



PcapDev::PcapDev(){
  pcap_if_t *alldevs;
  pcap_if_t *d;
  char err_buf[PCAP_ERRBUF_SIZE];   
  char packet_filter[]="ether src ff:ff:ff:c7:05:01"; //filter expression
  bpf_u_int32 netmask=0xffffff; 
  struct bpf_program fcode; // compile filter program  
  int i = 0;
  if (pcap_findalldevs(&alldevs, err_buf) == -1)
  {
      cerr <<"Error in pcap_findalldevs_ex:"<< err_buf << endl;
      exit(1);
  }
  for(d= alldevs; d != NULL; d= d->next)
  {
      cout << ++i << ":"<< d->name <<"    ";
      if (d->description)
          cout << d->description << endl;
      else
          cout<< "(No description available)" << endl;
  }
  int device_number;
  // cout << "plese select your etherner device: ";
  // cin >> device_number;
  //please set according to your host's ethernert port
  cin >> device_number;
  // device_number=1;

  d= alldevs;
  for(i=0; i < device_number -1; i++){
      d=d->next;        
  }
  //cout << ++i << ":"<< d->name <<"    ";
  if (d->description)
      cout << d->description << endl;
  else
      cout<< "(No description available)" << endl;

  /* open the ethernet device*/
  //dev = pcap_lookupdev(err_buf);
  //if (dev==NULL){
  //    cout<<"Could not find device "<<dev<<" : "<<err_buf<<endl;
  //    return -1;
  //}else{
//printf("Found Device %s\n",dev);
  //}
  dev_ = d->name;
  pcapHandle_ = pcap_open_live(dev_,65536,1,10000, err_buf);  //device name, snap length, promiscuous mode, to_ms, error_buffer
  if (pcapHandle_==NULL){
    cout<<"Could not open device "<<dev_<<" : "<<err_buf<<endl;
        exit(1);
  }   

  /* compile the filter */
  if (pcap_compile(pcapHandle_, &fcode, packet_filter, 1, netmask) < 0){
    cout<<"Unable to compile the packet filter. Check the syntax!"<<endl;
    pcap_close(pcapHandle_);
    exit(1);
  }

  /* apply filter*/ 
  if (pcap_setfilter(pcapHandle_, &fcode) < 0){
    cout<<"Filter address error. Can not apply filter!"<<endl;
    pcap_close(pcapHandle_);
    exit(1);
  }
  pcap_freecode(&fcode); 
  // pcap_freecode() is used to free up allocated memory pointed to by a
    // bpf_program struct generated by pcap_compile(3PCAP) when that BPF
    // program is no longer needed, for example after it has been made the
    // filter program for a pcap structure by a call to
    // pcap_setfilter(3PCAP).
    pcap_freealldevs(alldevs);
}

PcapDev::~PcapDev(){
    pcap_close(pcapHandle_);
}


int PcapDev::packetReceiver(){

    int ret=0;
    int fd=0;   //define a file descriptor 
    fd_set rfds; //file descriptor sets for "select" function (it's a bit arrray)
    struct timeval tv;  // strcuture represents elapsed time (declared in sys/time.h)
    const int TIMEOUT=60;  //timeout in seconds

    fd=pcap_fileno(pcapHandle_); //pcap_fileno returns the descriptor for the packet capture device
    FD_ZERO(&rfds);   //re-clears(empty) file descriptor set 
    FD_SET(fd,&rfds); //rebuild file descriptor set
    
    tv.tv_sec=TIMEOUT;
    tv.tv_usec=0;
 
    ret=select(fd+1, &rfds, NULL, NULL, &tv); 
    //select(): blocks the calling process until there is activity on file descriptor set or until the timeout period has expired
 
    if(-1==ret) cout<<"Select failed"<<endl;
    else if(ret){
        pcap_dispatch(pcapHandle_,1, gotPacket,NULL);
    }else{
        //#ifdef DEBUG
                cout<<"Select timeout on fd:"<<fd<<" Return code: "<<ret<<endl;
        //#endif
    }
    return ret;
}
